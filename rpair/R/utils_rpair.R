# called by rpair_gloss (glmnetfit) and rpair_hinge (gcdnetfit)
# checks the error message - makes fortran message human readable
jerr<- function (fit, ...)  UseMethod("jerr")

# translate fortran error codes - rpair_gloss
jerr.glmnetfit <- function(fit, maxit, pmax, loss_type){
  n = fit$jerr

  # glmnet errors
  if (n == 0)
    errlist = list(n = 0, fatal = FALSE, msg = "")
  else {
    outlist = {function(){
      if (n > 0) {
        if (n < 7777)
          msg = "Memory allocation error; contact package maintainer"
        else if (n == 7777)
          msg = "All used predictors have zero variance"
        else if (n == 10000)
          msg = "All penalty factors are <= 0"
        else msg = "Unknown error"
        list(n = n, fatal = TRUE, msg = msg)
      }
      else if (n < 0) {
        if (n > -10000)
          msg = paste("Convergence for ", -n, "th lambda value not reached after maxit=", maxit,
                      " iterations; solutions for larger lambdas returned", sep = "")

        if (n < -10000)
          msg = paste("Number of nonzero coefficients along the path exceeds pmax=",  pmax, " at ", -n - 10000,
                      "th lambda value; solutions for larger lambdas returned", sep = "")

        list(n = n, fatal = FALSE, msg = msg)
      }
    }}()
    errlist = switch(loss_type,
                     log = {function(){
                       if (n < -20000)
                         outlist$msg = paste("Max(p(1-p),1.0e-6 at ", -n - 20000, "th value of lambda; solutions for larger values of lambda returned")
                       if (outlist$msg != "Unknown error")
                         return(outlist)
                       if ( ((8000 < n) & (n < 9000)) | ((9000 < n) & (n < 10000)) )
                         msg = paste("Null probability for concordance < 1.0e-5")
                       else msg = "Unknown error"
                       list(n = n, fatal = TRUE, msg = msg)
                     }}(),
                     exp = {function(){
                       if (outlist$msg != "Unknown error")
                         return(outlist)
                       if (n == 8888)  msg = "NA error"
                       else if (n == 9999) msg = "No positive observation weights"
                       else msg = "Unknown error"
                       list(n = n, fatal = TRUE, msg = msg)
                     }}())

    names(errlist) = c("n", "fatal", "msg")
    errlist$msg = paste("from glmnet Fortran code (error code ",  n, "); ", errlist$msg, sep = "")
  }
  return(errlist)
}

# translate fortran error codes - rpair_hinge - optimizer (gcdnet)
jerr.gcdnetfit <- function(fit, maxit, pmax, loss_type){

  n = fit$jerr
  # gcdnet errors
  if (n == 0)
    msg <- ""
  if (n > 0) {
    if (n < 7777)
      msg <- "Memory allocation error"
    if (n == 7777)
      msg <- "All used predictors have zero variance"
    if (n == 10000)
      msg <- "All penalty factors are <= 0"
    n <- 1
    msg <- paste("in gcdnet fortran code -", msg)
  }
  if (n < 0) {
    if (n > -10000)
      msg <- paste("Convergence for ", -n, "th lambda value not reached after maxit=",
                   maxit, " iterations; solutions for larger lambdas returned",
                   sep = "")
    if (n < -10000)
      msg <- paste("Number of nonzero coefficients along the path exceeds pmax=",
                   pmax, " at ", -n - 10000, "th lambda value; solutions for larger lambdas returned",
                   sep = "")
    n <- -1
    msg <- paste("from gcdnet fortran code -", msg)
  }

  list(n = n, msg = msg)

}

#' Internal function - fix first lambda
#'
#' The first lambda value returned by the Fortran models requires correction.
#'
#' @param lam Lambda sequence from rpair fit object.
#'
#' @return Lambda sequence - corrected value for first lambda.
#'
#' @noRd
fix_lam<- function (lam) {
  if (length(lam) > 2) {
    llam = log(lam)
    lam[1] = exp(2 * llam[2] - llam[3])
  }
  lam
}

#' Internal function - get model coefficients
#'
#' Call the correct internal function for calculating coefficients for glmnet fit objects and
#' gcdnet fit objects. Used in rpair_gloss (glmnetfit) and rpair_hinge (gcdnetfit)
#'
#' @param fit The rpair fit object.
#' @param \dots Additional parameters to pass to glmnet or gcdnet getcoef functions.
#'
#' @noRd
getcoef <- function (fit, ...)  UseMethod("getcoef")

#' Internal function - get glmnetfit coefficients (rpair_gloss)
#'
#' Extract results from fit object generated by Fortran.
#'
#' @param fit Fit object generated by Fortran code.
#' @param nvars Number of features.
#' @param pmax Maximum number of variables that can be non-zero.
#' @param vnames Vector of feature names.
#'
#' @return List of results, inlcuding beta, df, dim, and lambda. See rpair documentation for details.
#'
#' @noRd
getcoef.glmnetfit <- function (fit, nvars, pmax, vnames) {

  lmu = fit$lmu
  if (lmu < 1) {
    warning("an empty model has been returned; probably a convergence issue")
    coefob = list(beta = zeromat(nvars, as.integer(1), vnames, "s0"), df = 0, dim = c(nvars, 1), lambda = Inf)
    return(coefob)
  }
  nin = fit$nin[seq(lmu)]
  ninmax = max(nin)
  lam = fit$alm[seq(lmu)]
  stepnames = paste("s", seq(lmu) - 1, sep = "")
  dd = c(nvars, lmu)
  if (ninmax > 0) {
    ca = matrix(fit$ca[seq(pmax * lmu)], pmax, lmu)[seq(ninmax), , drop = FALSE]
    df = apply(abs(ca) > 0, 2, sum)
    ja = fit$ia[seq(ninmax)]
    oja = order(ja)
    ja = rep(ja[oja], lmu)
    ia = cumsum(c(1, rep(ninmax, lmu)))
    beta = Matrix::drop0( new("dgCMatrix", Dim = dd, Dimnames = list(vnames, stepnames),
                              x = as.vector(ca[oja, ]), p = as.integer(ia - 1), i = as.integer(ja - 1)) )
  }
  else {
    beta = zeromat(nvars, lmu, vnames, stepnames)
    df = rep(0, lmu)
  }

  list(beta = beta, df = df, dim = dd, lambda = lam)
}

#' Internal function - get gcdnetfit coefficients (rpair_hinge)
#'
#' Extract results from fit object generated by Fortran.
#'
#' @param fit Fit object generated by Fortran code.
#' @param nvars Number of features.
#' @param pmax Maximum number of variables that can be non-zero.
#' @param vnames Vector of feature names.
#'
#' @return List of results, inlcuding beta, df, dim, and lambda. See rpair documentation for details.
#'
#' @noRd
getcoef.gcdnetfit <- function (fit, nvars, pmax, vnames) {

  nalam <- fit$nalam
  nbeta <- fit$nbeta[seq(nalam)]
  nbetamax <- max(nbeta)
  lam <- fit$alam[seq(nalam)]
  stepnames <- paste("s", seq(nalam) - 1, sep = "")

  dd <- c(nvars, nalam)
  if (nbetamax > 0) {
    beta <- matrix(fit$beta[seq(pmax * nalam)], pmax, nalam)[seq(nbetamax), , drop = FALSE]

    df <- apply(abs(beta) > 0, 2, sum)
    ja <- fit$ibeta[seq(nbetamax)]
    oja <- order(ja)
    ja <- rep(ja[oja], nalam)
    ibeta <- cumsum(c(1, rep(nbetamax, nalam)))
    beta <- new("dgCMatrix",
                Dim = dd,
                Dimnames = list(vnames, stepnames),
                x = as.vector(beta[oja, ]),
                p = as.integer(ibeta - 1),
                i = as.integer(ja - 1))
  }
  else {
    beta <- zeromat(nvars, nalam, vnames, stepnames)
    df <- rep(0, nalam)
  }

  list( beta = beta, df = df, dim = dd, lambda = lam)
}

#' Internal glmnet function - zeromat
#'
#' Return a nvars x nalam matrix of zeros. Used when the model returned is empty.
#'
#' @param nvars Number of features.
#' @param nalam Number of lambda values from Fortran fit object.
#' @param vnames Vector of variable names.
#' @param stepnames Vector of lambda names.
#'
#' @return A matrix of zeros
#'
#' @noRd
zeromat <- function (nvars, nalam, vnames, stepnames) {
  ca <- rep(0, nalam)
  ia <- seq(nalam + 1)
  ja <- rep(1, nalam)
  dd <- c(nvars, nalam)
  new("dgCMatrix", Dim = dd, Dimnames = list(vnames, stepnames),
      x = as.vector(ca), p = as.integer(ia - 1), i = as.integer(ja - 1))
}

#' Internal glmnet function - lambda.interp
#'
#' Performs linear interpolation of the lambdas to obtain a prediction at point(s) s.
#'
#' @param lambda Lambda sequence from the rpair fit object.
#' @param s Point(s) to make predictions on.
#'
#' @noRd
lambda.interp <- function (lambda, s)
{
  if (length(lambda) == 1) {
    nums = length(s)
    left = rep(1, nums)
    right = left
    sfrac = rep(1, nums)
  }
  else {
    k = length(lambda)
    sfrac <- (lambda[1] - s)/(lambda[1] - lambda[k])
    lambda <- (lambda[1] - lambda)/(lambda[1] - lambda[k])
    sfrac[sfrac < min(lambda)] <- min(lambda)
    sfrac[sfrac > max(lambda)] <- max(lambda)
    coord <- approx(lambda, seq(lambda), sfrac)$y
    left <- floor(coord)
    right <- ceiling(coord)
    sfrac = (sfrac - lambda[right])/(lambda[left] - lambda[right])
    sfrac[left == right] = 1
    sfrac[abs(lambda[left] - lambda[right]) < .Machine$double.eps] = 1
  }
  list(left = left, right = right, frac = sfrac)
}

#' Internal glmnet function - nonzeroCoef
#'
#' Determines which variables are nonzero in each fit.
#'
#' @param beta Matrix of beta coefficients.
#' @param bystep Whether to return nonzero variables per labmda (TRUE) or across all
#'    lambdas (FALSE).
#'
#' @returns If bystep=TRUE, a list of length nlambda, with indices of each nonzero variable for
#'    that lambda. Else, return a vector of variables that are nonzero for at least one lambda.
#'
#' @noRd
nonzeroCoef <- function (beta, bystep = FALSE)
{
  nr = nrow(beta)
  if (nr == 1) {
    if (bystep)
      apply(beta, 2, function(x) if (abs(x) > 0)
        1
        else NULL)
    else {
      if (any(abs(beta) > 0))
        1
      else NULL
    }
  }
  else {
    beta = abs(beta) > 0
    which = seq(nr)
    ones = rep(1, ncol(beta))
    nz = as.vector((beta %*% ones) > 0)
    which = which[nz]
    if (bystep) {
      if (length(which) > 0) {
        beta = as.matrix(beta[which, , drop = FALSE])
        nzel = function(x, which) if (any(x))
          which[x]
        else NULL
        which = apply(beta, 2, nzel, which)
        if (!is.list(which))
          which = data.frame(which)
        which
      }
      else {
        dn = dimnames(beta)[[2]]
        which = vector("list", length(dn))
        names(which) = dn
        which
      }
    }
    else which
  }
}
