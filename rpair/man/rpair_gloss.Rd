% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rpair_gloss.R
\name{rpair_gloss}
\alias{rpair_gloss}
\title{Fit GLM for pairwise survival ranking models}
\usage{
rpair_gloss(
  x,
  y,
  loss_type = c("exp", "log"),
  alpha = 1,
  nlambda = 100,
  lambda.min.ratio = ifelse(nobs0 <= nvars, 0.01, 1e-04),
  lambda = NULL,
  standardize = FALSE,
  thresh = 1e-07,
  dfmax = nvars + 1,
  pmax = min(ncol(x), nrow(x)),
  penalty.factor = rep(1, nvars),
  maxit = 1e+05,
  type.logistic = c("Newton", "modified.Newton"),
  use_glmnet = FALSE
)
}
\arguments{
\item{x}{Input matrix of dimension nobs x nvars; each row is an observation vector.}

\item{y}{Pairwise ranking analysis response variable. This function supports three types of input types:
(1) continuous values, (2) survival data, and (3) ranked pairs.}

\item{loss_type}{Loss function to use. Equivalent to "family" in glmnet package. One of c("log", "exp").}

\item{alpha}{The elasticnet mixing parameter. See \link[glmnet]{glmnet} for details. Default: 1.0 (lasso penalty).}

\item{nlambda}{Number of lambda values to evaluate. Default: 100.}

\item{lambda.min.ratio}{Smallest value for lambda as a fraction of lambda.max, the (data derived) entry value.
See \link[glmnet]{glmnet} for details. Default: ifelse(nobs0 <= nvars, 1e-2, 1e-4)}

\item{lambda}{A user supplied lambda sequence. Overrides the typical usage in which a lambda sequence is computed
using nlambda and lambda.min.ratio. Provide a decreasing sequence of lambda values with at least 2 entries.
Default: NULL.}

\item{standardize}{Logical flag for x variable standardization. Default: FALSE.}

\item{thresh}{Convergence threshold for coordinate descent. Default: 1e-7.}

\item{dfmax}{Limit the maximum number of variables in the model. Default: nvars+1.}

\item{pmax}{Limit the maximum number of variables that can be nonzero. Default: min(ncol(x), nrow(x)).}

\item{penalty.factor}{Vector of penalty factors to apply to each coefficient. Default: rep(1, nvars).}

\item{maxit}{Maximum number of passes over the data for all lambda values. Default: 100000.}

\item{type.logistic}{Only used by logistic loss. One of c("Newton", "modified.Newton"). If "Newton" then the
exact hessian is used, while "modified.Newton" uses an upper-bound on the hessian and can be faster.
Default: "Newton".}

\item{use_glmnet}{Whether to use the glmnet function glmnet.control for handling changes needed for upper
and lower limits. Only use if glment is installed. Uses rpair_control if FALSE. Default: FALSE.}
}
\value{
An object with S3 class \code{"rpair"}, "*", where "*" is \code{"lognet"} or \code{"fishnet"}. Contains
the following attributes:
 \itemize{
   \item{beta - a nvars x length(lambda) matrix of coefficients, stored in sparse column format}
   \item{df - the number of nonzero coefficients for each value of lambda}
   \item{dim - dimension of coefficient matrix}
   \item{lambda - The actual sequence of lambda values used}
   \item{npasses - total passes over the data summed over all lambda values}
   \item{jerr - error flag, for warnings and errors (largely for internal debugging)}
   \item{dev.ratio - The fraction of (null) deviance explained}
   \item{nulldev - the null deviance (per observation)}
   \item{call - the call that produced the object}
   \item{loss - the loss function used}
   \item{nobs - the number of observations}
 }
}
\description{
Fit a generalized linear model for pairwise survival ranking models using either logistic loss (concordance
regression) or exponential loss. Uses a modified implementation of \link[glmnet]{glmnet}. Refer to glmnet
documentation for further details.
}
\examples{
efit = rpair_gloss(ds1_x, ds1_y, loss_type = "exp")
lfit = rpair_gloss(ds1_x, ds1_y, loss_type = "log")

}
\author{
mubu, KC
}
